<script>
  const form = document.getElementById('messageForm');
  const messageInput = document.getElementById('message');
  const authorInput = document.getElementById('author');
  const imageUrlInput = document.getElementById('imageUrl');
  const submitBtn = document.getElementById('submitBtn');
  const statusMessage = document.getElementById('statusMessage');
  const charCount = document.getElementById('charCount');
  const debugInfo = document.getElementById('debugInfo');
  const imageValidation = document.getElementById('imageValidation');
  const imagePreview = document.getElementById('imagePreview');
  const imageLoading = document.getElementById('imageLoading');
  const rateLimitInfo = document.getElementById('rateLimitInfo');
  const lastMessageCard = document.getElementById('lastMessageCard');
  const lastMessageContent = document.getElementById('lastMessageContent');
  const messageOptionalLabel = document.getElementById('messageOptionalLabel');
  const messageRequiredLabel = document.getElementById('messageRequiredLabel');
  const authorOptionalLabel = document.getElementById('authorOptionalLabel');
  const authorRequiredLabel = document.getElementById('authorRequiredLabel');

  // Constants
  const RATE_LIMIT_MINUTES = 5;
  const RATE_LIMIT_MS = RATE_LIMIT_MINUTES * 60 * 1000;
  const AUTHOR_STORAGE_KEY = 'message_author';
  const PLUGIN_ID_STORAGE_KEY = 'plugin_id';
  const CONFIG_STORAGE_KEY = 'plugin_config';

  // UUID validation regex
  const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

  // Get encoded parameter from query string
  const urlParams = new URLSearchParams(window.location.search);
  const encodedParam = urlParams.get('p') || urlParams.get('plugin') || urlParams.get('id');
  const legacyWebhookParam = urlParams.get('webhook') || urlParams.get('url') || urlParams.get('plugin_id');

  // Base64 URL-safe decode
  function base64UrlDecode(str) {
    str = str.replace(/-/g, '+').replace(/_/g, '/');
    while (str.length % 4) {
      str += '=';
    }
    try {
      return atob(str);
    } catch (e) {
      return null;
    }
  }

  // Decode configuration from URL parameter
  function decodeConfig(encoded) {
    try {
      const decoded = base64UrlDecode(encoded);
      if (!decoded) return null;

      const config = JSON.parse(decoded);

      if (!config.id || !UUID_REGEX.test(config.id)) {
        return null;
      }

      return {
        pluginId: config.id,
        authorRequired: config.ar === true || config.ar === 1,
        messageRequired: config.mr === true || config.mr === 1
      };
    } catch (e) {
      console.error('Failed to decode config:', e);
      return null;
    }
  }

  // Extract plugin ID from legacy formats
  function extractPluginId(input) {
    if (!input) return null;

    const urlMatch = input.match(/usetrmnl\.com\/api\/custom_plugins\/([0-9a-f-]{36})/i);
    if (urlMatch) {
      return urlMatch[1];
    }

    if (UUID_REGEX.test(input)) {
      return input;
    }

    return null;
  }

  // Get plugin configuration
  function getPluginConfig() {
    let config = null;
    let source = 'none';

    if (encodedParam) {
      config = decodeConfig(encodedParam);
      if (config) {
        source = 'url_encoded';
        localStorage.setItem(PLUGIN_ID_STORAGE_KEY, config.pluginId);
        localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(config));
      }
    }

    if (!config && legacyWebhookParam) {
      const pluginId = extractPluginId(legacyWebhookParam);
      if (pluginId) {
        config = {
          pluginId: pluginId,
          authorRequired: false,
          messageRequired: false
        };
        source = 'url_legacy';
        localStorage.setItem(PLUGIN_ID_STORAGE_KEY, pluginId);
        localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(config));
      }
    }

    if (!config) {
      const storedConfig = localStorage.getItem(CONFIG_STORAGE_KEY);
      if (storedConfig) {
        try {
          config = JSON.parse(storedConfig);
          if (config.pluginId && UUID_REGEX.test(config.pluginId)) {
            source = 'localStorage';
          } else {
            config = null;
          }
        } catch (e) {
          const storedPluginId = localStorage.getItem(PLUGIN_ID_STORAGE_KEY);
          if (storedPluginId && UUID_REGEX.test(storedPluginId)) {
            config = {
              pluginId: storedPluginId,
              authorRequired: false,
              messageRequired: false
            };
            source = 'localStorage';
          }
        }
      }
    }

    return { config, source };
  }

  const { config, source } = getPluginConfig();

  // Fetch last message from API
  async function fetchLastMessage() {
    if (!config || !config.pluginId) return null;

    try {
      const response = await fetch(`https://usetrmnl.com/api/custom_plugins/${config.pluginId}`);

      if (!response.ok) {
        console.error('Failed to fetch last message:', response.status);
        return null;
      }

      const data = await response.json();

      // Check if we have messages array
      if (data.merge_variables && data.merge_variables.messages && Array.isArray(data.merge_variables.messages)) {
        const messages = data.merge_variables.messages;
        if (messages.length > 0) {
          return messages[messages.length - 1]; // Return most recent message
        }
      }

      return null;
    } catch (error) {
      console.error('Error fetching last message:', error);
      return null;
    }
  }

  // Display last message in card
  function displayLastMessage(message) {
    if (!message || !message.timestamp_utc) {
      lastMessageCard.style.display = 'none';
      return;
    }

    const timestamp = new Date(message.timestamp_utc);
    const localTime = timestamp.toLocaleString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });

    const author = message.author || 'Anonymous';

    lastMessageContent.innerHTML = `
      <div class="last-message-author">${author}</div>
      <div class="last-message-time">${localTime}</div>
    `;

    lastMessageCard.style.display = 'block';
  }

  // Check if we can send based on last message timestamp
  function checkCanSendBasedOnLastMessage(lastMessage) {
    if (!lastMessage || !lastMessage.timestamp_utc) {
      return true;
    }

    const lastTimestamp = new Date(lastMessage.timestamp_utc).getTime();
    const now = Date.now();
    const timeSinceLast = now - lastTimestamp;

    if (timeSinceLast < RATE_LIMIT_MS) {
      const remainingTime = RATE_LIMIT_MS - timeSinceLast;
      const remainingMinutes = Math.floor(remainingTime / (60 * 1000));
      const remainingSeconds = Math.ceil((remainingTime % (60 * 1000)) / 1000);

      submitBtn.disabled = true;
      rateLimitInfo.innerHTML = `Last message was sent too recently. Please wait <span class="countdown">${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}</span>`;

      // Update countdown
      const countdownInterval = setInterval(() => {
        const newRemainingTime = RATE_LIMIT_MS - (Date.now() - lastTimestamp);

        if (newRemainingTime <= 0) {
          clearInterval(countdownInterval);
          submitBtn.disabled = false;
          rateLimitInfo.textContent = `You can send one message every ${RATE_LIMIT_MINUTES} minutes`;
        } else {
          const newRemainingMinutes = Math.floor(newRemainingTime / (60 * 1000));
          const newRemainingSeconds = Math.ceil((newRemainingTime % (60 * 1000)) / 1000);
          rateLimitInfo.innerHTML = `Last message was sent too recently. Please wait <span class="countdown">${newRemainingMinutes}:${newRemainingSeconds.toString().padStart(2, '0')}</span>`;
        }
      }, 1000);

      return false;
    }

    submitBtn.disabled = false;
    rateLimitInfo.textContent = `You can send one message every ${RATE_LIMIT_MINUTES} minutes`;
    return true;
  }

  // Initialize the form
  async function initializeForm() {
    if (!config) {
      handleInvalidConfig();
      return;
    }

    // Update UI based on configuration
    if (config.authorRequired) {
      authorOptionalLabel.style.display = 'none';
      authorRequiredLabel.style.display = 'inline';
      authorInput.required = true;
      authorInput.placeholder = 'Your name is required';
    }

    if (config.messageRequired) {
      messageOptionalLabel.style.display = 'none';
      messageRequiredLabel.style.display = 'inline';
      messageInput.required = true;
      messageInput.placeholder = 'Message is required';
    }

    // Load saved author from localStorage
    const savedAuthor = localStorage.getItem(AUTHOR_STORAGE_KEY);
    if (savedAuthor) {
      authorInput.value = savedAuthor;
    }

    // Fetch and display last message
    lastMessageContent.innerHTML = '<div class="last-message-loading">Loading last message...</div>';
    lastMessageCard.style.display = 'block';

    const lastMessage = await fetchLastMessage();
    displayLastMessage(lastMessage);
    checkCanSendBasedOnLastMessage(lastMessage);

    // Show debug info
    let sourceText = '';
    switch (source) {
      case 'url_encoded':
        sourceText = 'Encoded URL parameter (saved to localStorage)';
        break;
      case 'url_legacy':
        sourceText = 'Legacy URL parameter (saved to localStorage)';
        break;
      case 'localStorage':
        sourceText = 'localStorage';
        break;
      default:
        sourceText = 'unknown';
    }

    debugInfo.innerHTML = `
      Plugin ID: ${config.pluginId}<br>
      Source: <span class="plugin-source">${sourceText}</span><br>
      Author Required: ${config.authorRequired ? 'Yes' : 'No'}<br>
      Message Required: ${config.messageRequired ? 'Yes' : 'No'}
    `;
    debugInfo.style.display = 'block';

    if (source === 'localStorage') {
      showMessage('✓ Using saved configuration from previous session', 'success');
      setTimeout(() => {
        statusMessage.classList.remove('show');
      }, 3000);
    }
  }

  function handleInvalidConfig() {
    if (encodedParam) {
      showMessage('⚠ Invalid or corrupted configuration parameter', 'error');
    } else if (legacyWebhookParam) {
      showMessage('⚠ Invalid plugin ID or webhook URL format', 'error');
    } else {
      showMessage('⚠ No configuration detected. Please scan the QR code to access this form.', 'error');
    }
    submitBtn.disabled = true;
  }

  // Character counter
  messageInput.addEventListener('input', () => {
    charCount.textContent = messageInput.value.length;
  });

  // Save author to localStorage
  authorInput.addEventListener('input', () => {
    const authorValue = authorInput.value.trim();
    if (authorValue) {
      localStorage.setItem(AUTHOR_STORAGE_KEY, authorValue);
    } else {
      localStorage.removeItem(AUTHOR_STORAGE_KEY);
    }
  });

  // Image URL validation
  let imageValidationTimeout;
  imageUrlInput.addEventListener('input', () => {
    clearTimeout(imageValidationTimeout);

    const url = imageUrlInput.value.trim();

    imageValidation.className = 'validation';
    imagePreview.className = 'image-preview';
    imageLoading.className = 'image-loading';
    imagePreview.innerHTML = '';

    if (!url) {
      return;
    }

    try {
      new URL(url);
    } catch (e) {
      imageValidation.textContent = 'Please enter a valid URL';
      imageValidation.className = 'validation error';
      return;
    }

    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    const isImageUrl = imageExtensions.some(ext =>
      url.toLowerCase().includes(ext)
    );

    if (!isImageUrl) {
      imageValidation.textContent = 'URL does not appear to point to an image';
      imageValidation.className = 'validation error';
      return;
    }

    imageValidationTimeout = setTimeout(() => {
      validateImageUrl(url);
    }, 500);
  });

  function validateImageUrl(url) {
    imageLoading.className = 'image-loading show';
    imagePreview.className = 'image-preview';

    const img = new Image();
    img.onload = function() {
      imageLoading.className = 'image-loading';
      imageValidation.textContent = '✓ Valid image URL';
      imageValidation.className = 'validation success';

      imagePreview.innerHTML = `<img src="${url}" alt="Image preview">`;
      imagePreview.className = 'image-preview show';
    };

    img.onerror = function() {
      imageLoading.className = 'image-loading';
      imageValidation.textContent = 'Image could not be loaded. Please check the URL.';
      imageValidation.className = 'validation error';
    };

    img.src = url;
  }

  function showMessage(text, type) {
    statusMessage.textContent = text;
    statusMessage.className = `message ${type} show`;

    if (type === 'success') {
      setTimeout(() => {
        statusMessage.classList.remove('show');
      }, 5000);
    }
  }

  // Handle form submission - CORRECTED VERSION
  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    if (!config || !config.pluginId) {
      showMessage('Error: No plugin ID available. Please scan the QR code to access this form.', 'error');
      return;
    }

    const messageText = messageInput.value.trim();
    const authorText = authorInput.value.trim() || 'Anonymous';
    const imageUrl = imageUrlInput.value.trim();

    // Validation
    if (config.messageRequired && !messageText) {
      showMessage('Message is required.', 'error');
      messageInput.classList.add('error');
      return;
    }

    if (config.authorRequired && !authorText) {
      showMessage('Author name is required.', 'error');
      authorInput.classList.add('error');
      return;
    }

    messageInput.classList.remove('error');
    authorInput.classList.remove('error');

    if (!config.messageRequired && !messageText && !imageUrl) {
      showMessage('Please enter either a message or an image URL.', 'error');
      return;
    }

    if (imageUrl) {
      try {
        new URL(imageUrl);
      } catch (e) {
        showMessage('Please enter a valid image URL.', 'error');
        return;
      }
    }

    submitBtn.disabled = true;
    submitBtn.textContent = 'Sending...';

    const webhookUrl = `https://usetrmnl.com/api/custom_plugins/${config.pluginId}`;
    const timestampUtc = new Date().toISOString();

    // Create payload in the correct format for TRMNL streaming
    const payload = {
      message: messageText,
      author: authorText,
      image_url: imageUrl || undefined, // Only include if provided
      timestamp_utc: timestampUtc
    };

    console.log('Sending to:', webhookUrl);
    console.log('Payload:', payload);

    try {
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
      });

      console.log('Response status:', response.status);

      if (response.ok) {
        showMessage('✓ Message sent successfully!', 'success');

        // Refresh last message display
        const lastMessage = await fetchLastMessage();
        displayLastMessage(lastMessage);
        checkCanSendBasedOnLastMessage(lastMessage);

        // Clear form but keep author
        messageInput.value = '';
        imageUrlInput.value = '';
        charCount.textContent = '0';

        imageValidation.className = 'validation';
        imagePreview.className = 'image-preview';
        imagePreview.innerHTML = '';
      } else {
        const errorText = await response.text();
        console.error('Error response:', errorText);

        // More specific error handling
        if (response.status === 413) {
          showMessage('Message too large. Please shorten your message or use a smaller image.', 'error');
        } else if (response.status === 429) {
          showMessage('Rate limit exceeded. Please wait before sending another message.', 'error');
        } else {
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
      }
    } catch (error) {
      console.error('Full error:', error);
      showMessage(`Failed to send message: ${error.message}`, 'error');
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Send Message';
    }
  });

  document.addEventListener('DOMContentLoaded', initializeForm);
</script>