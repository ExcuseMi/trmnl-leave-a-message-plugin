<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Leave a Message</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
      max-width: 500px;
      width: 100%;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 28px;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .last-message-card {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 12px 16px;
      margin-bottom: 20px;
      border-radius: 8px;
    }

    .last-message-header {
      font-size: 12px;
      font-weight: 600;
      color: #667eea;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .last-message-author {
      font-size: 14px;
      color: #333;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .last-message-time {
      font-size: 12px;
      color: #666;
    }

    .last-message-loading {
      color: #999;
      font-size: 13px;
      font-style: italic;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #333;
      font-weight: 500;
      font-size: 14px;
    }

    .required-asterisk {
      color: #e74c3c;
      margin-left: 2px;
    }

    input, textarea, select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      font-family: inherit;
      transition: border-color 0.3s;
    }

    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }

    input.error, textarea.error {
      border-color: #e74c3c;
    }

    textarea {
      resize: vertical;
      min-height: 120px;
    }

    select {
      cursor: pointer;
      background: white;
    }

    button {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .message {
      margin-top: 20px;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      font-size: 14px;
      display: none;
    }

    .message.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .message.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .message.warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }

    .message.show {
      display: block;
    }

    .char-count {
      text-align: right;
      font-size: 12px;
      color: #999;
      margin-top: 4px;
    }

    .debug {
      margin-top: 10px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }

    .validation {
      font-size: 12px;
      margin-top: 4px;
      display: none;
    }

    .validation.error {
      color: #e74c3c;
      display: block;
    }

    .validation.success {
      color: #27ae60;
      display: block;
    }

    .image-preview {
      margin-top: 10px;
      display: none;
      max-width: 100%;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .image-preview img {
      width: 100%;
      height: auto;
      display: block;
    }

    .image-preview.show {
      display: block;
    }

    .image-loading {
      display: none;
      text-align: center;
      padding: 10px;
      color: #666;
      font-size: 14px;
    }

    .image-loading.show {
      display: block;
    }

    .optional-label {
      color: #999;
      font-weight: normal;
    }

    .rate-limit-info {
      font-size: 12px;
      color: #666;
      margin-top: 8px;
      text-align: center;
    }

    .countdown {
      font-weight: bold;
      color: #e74c3c;
    }

    .plugin-source {
      color: #667eea;
      font-weight: 500;
    }

    .mode-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .mode-button {
      flex: 1;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      text-align: center;
      font-weight: 500;
      transition: all 0.3s;
    }

    .mode-button:hover {
      border-color: #667eea;
    }

    .mode-button.active {
      border-color: #667eea;
      background: #f0f4ff;
      color: #667eea;
    }

    .canvas-container {
      display: none;
      margin-top: 10px;
    }

    .canvas-container.show {
      display: block;
    }

    #drawingCanvas {
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      cursor: crosshair;
      touch-action: none;
      width: 100%;
      display: block;
    }

    .canvas-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .canvas-controls button {
      flex: 1;
      min-width: 100px;
      padding: 8px;
      font-size: 14px;
    }

    .color-picker {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .color-option {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid #e0e0e0;
      transition: transform 0.2s;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.active {
      border-color: #667eea;
      border-width: 3px;
    }

    .brush-size {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }

    .brush-size input {
      flex: 1;
    }

    .size-indicator {
      min-width: 40px;
      text-align: center;
      font-weight: 500;
    }

    .webhook-override {
      margin-top: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #dee2e6;
    }

    .webhook-override h3 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #495057;
    }

    .size-info {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }

    .size-info.warning {
      color: #f39c12;
    }

    .size-info.error {
      color: #e74c3c;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üì¨ Leave a Message</h1>
    <p class="subtitle">Your message, image, or drawing will appear on the TRMNL display</p>

    <div id="lastMessageCard" class="last-message-card" style="display: none;">
      <div class="last-message-header">Latest Message</div>
      <div id="lastMessageContent"></div>
    </div>

    <form id="messageForm">
      <!-- Mode Selector -->
      <div class="mode-selector">
        <button type="button" class="mode-button active" data-mode="message">üí¨ Message</button>
        <button type="button" class="mode-button" data-mode="image">üñºÔ∏è Image</button>
        <button type="button" class="mode-button" data-mode="draw">‚úèÔ∏è Draw</button>
      </div>

      <!-- Message Mode -->
      <div id="messageMode" class="mode-content">
        <div class="form-group">
          <label for="message">
            Message
            <span class="optional-label" id="messageOptionalLabel">(optional if sending an image)</span>
            <span class="required-asterisk" id="messageRequiredLabel" style="display: none;">*</span>
          </label>
          <textarea
            id="message"
            name="message"
            maxlength="280"
            placeholder="What's on your mind?"></textarea>
          <div class="char-count"><span id="charCount">0/280</span></div>
        </div>

        <div class="form-group">
          <label for="author">
            Your Name
            <span class="optional-label" id="authorOptionalLabel">(optional)</span>
            <span class="required-asterisk" id="authorRequiredLabel" style="display: none;">*</span>
          </label>
          <input
            type="text"
            id="author"
            name="author"
            maxlength="50"
            placeholder="Leave blank for anonymous">
        </div>
      </div>

      <!-- Image Mode -->
      <div id="imageMode" class="mode-content" style="display: none;">
        <div class="form-group">
          <label for="imageUrl">Image URL <span class="required-asterisk">*</span></label>
          <input
            type="url"
            id="imageUrl"
            name="imageUrl"
            placeholder="https://example.com/image.jpg">
          <div class="validation" id="imageValidation"></div>
          <div class="image-loading" id="imageLoading">Checking image...</div>
          <div class="image-preview" id="imagePreview"></div>
          <div style="font-size: 12px; color: #666; margin-top: 4px;">
            Add a link to an image to display with your message
          </div>
        </div>

        <div class="form-group">
          <label for="authorImage">
            Your Name
            <span class="optional-label" id="authorImageOptionalLabel">(optional)</span>
            <span class="required-asterisk" id="authorImageRequiredLabel" style="display: none;">*</span>
          </label>
          <input
            type="text"
            id="authorImage"
            name="authorImage"
            maxlength="50"
            placeholder="Leave blank for anonymous">
        </div>
      </div>

      <!-- Draw Mode -->
      <div id="drawMode" class="mode-content" style="display: none;">
        <div class="form-group">
          <label>Draw Your Message</label>
          <div class="canvas-container show">
            <canvas id="drawingCanvas" width="400" height="300"></canvas>
            <div class="color-picker">
              <div class="color-option active" data-color="#000000" style="background: #000000;"></div>
              <div class="color-option" data-color="#ffffff" style="background: #ffffff; border-color: #ccc;"></div>
              <div class="color-option" data-color="#667eea" style="background: #667eea;"></div>
              <div class="color-option" data-color="#e74c3c" style="background: #e74c3c;"></div>
              <div class="color-option" data-color="#27ae60" style="background: #27ae60;"></div>
              <div class="color-option" data-color="#f39c12" style="background: #f39c12;"></div>
            </div>
            <div class="brush-size">
              <label style="margin: 0;">Brush Size:</label>
              <input type="range" id="brushSize" min="1" max="20" value="3">
              <span class="size-indicator" id="sizeIndicator">3px</span>
            </div>
            <div class="canvas-controls">
              <button type="button" id="clearCanvas">Clear</button>
              <button type="button" id="undoCanvas">Undo</button>
            </div>
            <div class="size-info" id="canvasSizeInfo"></div>
          </div>
        </div>

        <div class="form-group">
          <label for="authorDraw">
            Your Name
            <span class="optional-label" id="authorDrawOptionalLabel">(optional)</span>
            <span class="required-asterisk" id="authorDrawRequiredLabel" style="display: none;">*</span>
          </label>
          <input
            type="text"
            id="authorDraw"
            name="authorDraw"
            maxlength="50"
            placeholder="Leave blank for anonymous">
        </div>
      </div>

      <button type="submit" id="submitBtn">Send Message</button>
      <div class="rate-limit-info" id="rateLimitInfo"></div>
    </form>

    <!-- Webhook Override Section -->
    <div class="webhook-override">
      <h3>üîß Advanced Settings</h3>
      <div class="form-group" style="margin-bottom: 0;">
        <label for="webhookOverride">Override Plugin ID / Webhook URL</label>
        <input
          type="text"
          id="webhookOverride"
          name="webhookOverride"
          placeholder="Paste plugin ID or webhook URL here">
        <div style="font-size: 12px; color: #666; margin-top: 4px;">
          Leave blank to use the configuration from the QR code
        </div>
      </div>
    </div>

    <div id="statusMessage" class="message"></div>
    <div id="debugInfo" class="debug" style="display: none;"></div>
  </div>
<script>
  // Constants
  const RATE_LIMIT_MINUTES = 5;
  const RATE_LIMIT_MS = RATE_LIMIT_MINUTES * 60 * 1000;
  const AUTHOR_STORAGE_KEY = 'message_author';
  const PLUGIN_ID_STORAGE_KEY = 'plugin_id';
  const CONFIG_STORAGE_KEY = 'plugin_config';
  const MAX_TOTAL_SIZE = 2000;
  const STREAM_LIMIT = 2;
  const MAX_MESSAGE_LENGTH = 280;
  const MAX_IMAGE_SIZE_KB = 800; // Max size for drawing in KB (800KB for base64 after compression)

  const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

  // DOM Elements
  const form = document.getElementById('messageForm');
  const messageInput = document.getElementById('message');
  const authorInput = document.getElementById('author');
  const authorImageInput = document.getElementById('authorImage');
  const authorDrawInput = document.getElementById('authorDraw');
  const imageUrlInput = document.getElementById('imageUrl');
  const webhookOverride = document.getElementById('webhookOverride');
  const submitBtn = document.getElementById('submitBtn');
  const statusMessage = document.getElementById('statusMessage');
  const charCount = document.getElementById('charCount');
  const debugInfo = document.getElementById('debugInfo');
  const imageValidation = document.getElementById('imageValidation');
  const imagePreview = document.getElementById('imagePreview');
  const imageLoading = document.getElementById('imageLoading');
  const rateLimitInfo = document.getElementById('rateLimitInfo');
  const lastMessageCard = document.getElementById('lastMessageCard');
  const lastMessageContent = document.getElementById('lastMessageContent');

  // Mode switching
  const modeButtons = document.querySelectorAll('.mode-button');
  const messageMode = document.getElementById('messageMode');
  const imageMode = document.getElementById('imageMode');
  const drawMode = document.getElementById('drawMode');
  let currentMode = 'message';

  // Canvas setup
  const canvas = document.getElementById('drawingCanvas');
  const ctx = canvas.getContext('2d');
  const brushSize = document.getElementById('brushSize');
  const sizeIndicator = document.getElementById('sizeIndicator');
  const canvasSizeInfo = document.getElementById('canvasSizeInfo');
  const colorOptions = document.querySelectorAll('.color-option');

  let isDrawing = false;
  let currentColor = '#000000';
  let currentBrushSize = 3;
  let drawingHistory = [];
  let currentStep = -1;

  // Initialize canvas
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  saveCanvasState();

  // Get URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const encodedParam = urlParams.get('p') || urlParams.get('plugin') || urlParams.get('id');
  const legacyWebhookParam = urlParams.get('webhook') || urlParams.get('url') || urlParams.get('plugin_id');

  function base64UrlDecode(str) {
    str = str.replace(/-/g, '+').replace(/_/g, '/');
    while (str.length % 4) {
      str += '=';
    }
    try {
      return atob(str);
    } catch (e) {
      return null;
    }
  }

  function decodeConfig(encoded) {
    try {
      const decoded = base64UrlDecode(encoded);
      if (!decoded) return null;

      const config = JSON.parse(decoded);

      if (!config.id || !UUID_REGEX.test(config.id)) {
        return null;
      }

      return {
        pluginId: config.id,
        authorRequired: config.ar === true || config.ar === 1,
        messageRequired: config.mr === true || config.mr === 1
      };
    } catch (e) {
      console.error('Failed to decode config:', e);
      return null;
    }
  }

  function extractPluginId(input) {
    if (!input) return null;

    const urlMatch = input.match(/usetrmnl\.com\/api\/custom_plugins\/([0-9a-f-]{36})/i);
    if (urlMatch) {
      return urlMatch[1];
    }

    if (UUID_REGEX.test(input)) {
      return input;
    }

    return null;
  }

  function getPluginConfig() {
    // Check for webhook override first
    const overrideValue = webhookOverride.value.trim();
    if (overrideValue) {
      const pluginId = extractPluginId(overrideValue);
      if (pluginId) {
        return {
          config: {
            pluginId: pluginId,
            authorRequired: false,
            messageRequired: false
          },
          source: 'manual_override'
        };
      }
    }

    let config = null;
    let source = 'none';

    if (encodedParam) {
      config = decodeConfig(encodedParam);
      if (config) {
        source = 'url_encoded';
        localStorage.setItem(PLUGIN_ID_STORAGE_KEY, config.pluginId);
        localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(config));
      }
    }

    if (!config && legacyWebhookParam) {
      const pluginId = extractPluginId(legacyWebhookParam);
      if (pluginId) {
        config = {
          pluginId: pluginId,
          authorRequired: false,
          messageRequired: false
        };
        source = 'url_legacy';
        localStorage.setItem(PLUGIN_ID_STORAGE_KEY, pluginId);
        localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(config));
      }
    }

    if (!config) {
      const storedConfig = localStorage.getItem(CONFIG_STORAGE_KEY);
      if (storedConfig) {
        try {
          config = JSON.parse(storedConfig);
          if (config.pluginId && UUID_REGEX.test(config.pluginId)) {
            source = 'localStorage';
          } else {
            config = null;
          }
        } catch (e) {
          const storedPluginId = localStorage.getItem(PLUGIN_ID_STORAGE_KEY);
          if (storedPluginId && UUID_REGEX.test(storedPluginId)) {
            config = {
              pluginId: storedPluginId,
              authorRequired: false,
              messageRequired: false
            };
            source = 'localStorage';
          }
        }
      }
    }

    return { config, source };
  }

  // Mode switching
  modeButtons.forEach(button => {
    button.addEventListener('click', () => {
      const mode = button.dataset.mode;

      modeButtons.forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');

      messageMode.style.display = 'none';
      imageMode.style.display = 'none';
      drawMode.style.display = 'none';

      if (mode === 'message') {
        messageMode.style.display = 'block';
      } else if (mode === 'image') {
        imageMode.style.display = 'block';
      } else if (mode === 'draw') {
        drawMode.style.display = 'block';
        updateCanvasSize();
      }

      currentMode = mode;
    });
  });

  // Canvas drawing
  function saveCanvasState() {
    currentStep++;
    if (currentStep < drawingHistory.length) {
      drawingHistory = drawingHistory.slice(0, currentStep);
    }
    drawingHistory.push(canvas.toDataURL());
    updateCanvasSize();
  }

  function restoreCanvasState(step) {
    const img = new Image();
    img.onload = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      updateCanvasSize();
    };
    img.src = drawingHistory[step];
  }

  function getCanvasDataURL(quality = 0.7) {
    // Try to compress as JPEG first for smaller size
    const jpegData = canvas.toDataURL('image/jpeg', quality);
    const pngData = canvas.toDataURL('image/png');

    // Return whichever is smaller
    return jpegData.length < pngData.length ? jpegData : pngData;
  }

  function updateCanvasSize() {
    const dataUrl = getCanvasDataURL();
    const sizeKB = Math.round((dataUrl.length * 3/4) / 1024);

    canvasSizeInfo.textContent = `Drawing size: ${sizeKB} KB`;

    if (sizeKB > MAX_IMAGE_SIZE_KB) {
      canvasSizeInfo.className = 'size-info error';
      canvasSizeInfo.textContent += ` (exceeds ${MAX_IMAGE_SIZE_KB} KB limit - please simplify your drawing)`;
    } else if (sizeKB > MAX_IMAGE_SIZE_KB * 0.8) {
      canvasSizeInfo.className = 'size-info warning';
      canvasSizeInfo.textContent += ' (approaching size limit)';
    } else {
      canvasSizeInfo.className = 'size-info';
    }
  }

  function startDrawing(e) {
    isDrawing = true;
    draw(e);
  }

  function stopDrawing() {
    if (isDrawing) {
      isDrawing = false;
      ctx.beginPath();
      saveCanvasState();
    }
  }

  function draw(e) {
    if (!isDrawing) return;

    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || e.touches[0].clientX) - rect.left;
    const y = (e.clientY || e.touches[0].clientY) - rect.top;

    ctx.strokeStyle = currentColor;
    ctx.lineWidth = currentBrushSize;

    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
  }

  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    startDrawing(e);
  });
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    draw(e);
  });
  canvas.addEventListener('touchend', stopDrawing);

  colorOptions.forEach(option => {
    option.addEventListener('click', () => {
      colorOptions.forEach(opt => opt.classList.remove('active'));
      option.classList.add('active');
      currentColor = option.dataset.color;
    });
  });

  brushSize.addEventListener('input', () => {
    currentBrushSize = brushSize.value;
    sizeIndicator.textContent = `${currentBrushSize}px`;
  });

  document.getElementById('clearCanvas').addEventListener('click', () => {
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    saveCanvasState();
  });

  document.getElementById('undoCanvas').addEventListener('click', () => {
    if (currentStep > 0) {
      currentStep--;
      restoreCanvasState(currentStep);
    }
  });

  // Character counter
  messageInput.addEventListener('input', () => {
    const length = messageInput.value.length;
    charCount.textContent = `${length}/${MAX_MESSAGE_LENGTH}`;

    if (length > MAX_MESSAGE_LENGTH) {
      charCount.style.color = '#ff4444';
    } else {
      charCount.style.color = '';
    }
  });

  // Save author to localStorage
  function setupAuthorSync(input) {
    input.addEventListener('input', () => {
      const authorValue = input.value.trim();
      if (authorValue) {
        localStorage.setItem(AUTHOR_STORAGE_KEY, authorValue);
        // Sync to other author inputs
        [authorInput, authorImageInput, authorDrawInput].forEach(inp => {
          if (inp !== input) inp.value = authorValue;
        });
      } else {
        localStorage.removeItem(AUTHOR_STORAGE_KEY);
      }
    });
  }

  setupAuthorSync(authorInput);
  setupAuthorSync(authorImageInput);
  setupAuthorSync(authorDrawInput);

  // Image URL validation
  let imageValidationTimeout;
  imageUrlInput.addEventListener('input', () => {
    clearTimeout(imageValidationTimeout);

    const url = imageUrlInput.value.trim();

    imageValidation.className = 'validation';
    imagePreview.className = 'image-preview';
    imageLoading.className = 'image-loading';
    imagePreview.innerHTML = '';

    if (!url) {
      return;
    }

    try {
      new URL(url);
    } catch (e) {
      imageValidation.textContent = 'Please enter a valid URL';
      imageValidation.className = 'validation error';
      return;
    }

    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    const isImageUrl = imageExtensions.some(ext =>
      url.toLowerCase().includes(ext)
    );

    if (!isImageUrl) {
      imageValidation.textContent = 'URL does not appear to point to an image';
      imageValidation.className = 'validation error';
      return;
    }

    imageValidationTimeout = setTimeout(() => {
      validateImageUrl(url);
    }, 500);
  });

  function validateImageUrl(url) {
    imageLoading.className = 'image-loading show';
    imagePreview.className = 'image-preview';

    const img = new Image();
    img.onload = function() {
      imageLoading.className = 'image-loading';
      imageValidation.textContent = '‚úì Valid image URL';
      imageValidation.className = 'validation success';

      imagePreview.innerHTML = `<img src="${url}" alt="Image preview">`;
      imagePreview.className = 'image-preview show';
    };

    img.onerror = function() {
      imageLoading.className = 'image-loading';
      imageValidation.textContent = 'Image could not be loaded. Please check the URL.';
      imageValidation.className = 'validation error';
    };

    img.src = url;
  }

  function showMessage(text, type) {
    statusMessage.textContent = text;
    statusMessage.className = `message ${type} show`;

    if (type === 'success') {
      setTimeout(() => {
        statusMessage.classList.remove('show');
      }, 5000);
    }
  }

  function getJsonSize(obj) {
    return new Blob([JSON.stringify(obj)]).size;
  }

  async function fetchLastMessage() {
    const { config } = getPluginConfig();
    if (!config || !config.pluginId) return null;

    try {
      const response = await fetch(`https://usetrmnl.com/api/custom_plugins/${config.pluginId}`);

      if (!response.ok) {
        console.error('Failed to fetch last message:', response.status);
        return null;
      }

      const data = await response.json();

      if (data.merge_variables && data.merge_variables.messages && Array.isArray(data.merge_variables.messages)) {
        const messages = data.merge_variables.messages;
        if (messages.length > 0) {
          return messages[messages.length - 1];
        }
      }

      return null;
    } catch (error) {
      console.error('Error fetching last message:', error);
      return null;
    }
  }

  async function fetchAllMessages() {
    const { config } = getPluginConfig();
    if (!config || !config.pluginId) return [];

    try {
      const response = await fetch(`https://usetrmnl.com/api/custom_plugins/${config.pluginId}`);

      if (!response.ok) {
        return [];
      }

      const data = await response.json();

      if (data.merge_variables && data.merge_variables.messages && Array.isArray(data.merge_variables.messages)) {
        return data.merge_variables.messages;
      }

      return [];
    } catch (error) {
      console.error('Error fetching messages:', error);
      return [];
    }
  }

  function displayLastMessage(message) {
    if (!message || !message.timestamp_utc) {
      lastMessageCard.style.display = 'none';
      return;
    }

    const timestamp = new Date(message.timestamp_utc);
    const localTime = timestamp.toLocaleString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });

    const author = message.author || 'Anonymous';

    lastMessageContent.innerHTML = `
      <div class="last-message-author">${author}</div>
      <div class="last-message-time">${localTime}</div>
    `;

    lastMessageCard.style.display = 'block';
  }

  function checkCanSendBasedOnLastMessage(lastMessage) {
    if (!lastMessage || !lastMessage.timestamp_utc) {
      rateLimitInfo.textContent = `You can send one message every ${RATE_LIMIT_MINUTES} minutes`;
      return true;
    }

    const lastTimestamp = new Date(lastMessage.timestamp_utc).getTime();
    const now = Date.now();
    const timeSinceLast = now - lastTimestamp;

    if (timeSinceLast < RATE_LIMIT_MS) {
      const remainingTime = RATE_LIMIT_MS - timeSinceLast;
      const remainingMinutes = Math.floor(remainingTime / (60 * 1000));
      const remainingSeconds = Math.ceil((remainingTime % (60 * 1000)) / 1000);

      submitBtn.disabled = true;
      rateLimitInfo.innerHTML = `Last message was sent too recently. Please wait <span class="countdown">${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}</span>`;

      const countdownInterval = setInterval(() => {
        const newRemainingTime = RATE_LIMIT_MS - (Date.now() - lastTimestamp);

        if (newRemainingTime <= 0) {
          clearInterval(countdownInterval);
          submitBtn.disabled = false;
          rateLimitInfo.textContent = `You can send one message every ${RATE_LIMIT_MINUTES} minutes`;
        } else {
          const newRemainingMinutes = Math.floor(newRemainingTime / (60 * 1000));
          const newRemainingSeconds = Math.ceil((newRemainingTime % (60 * 1000)) / 1000);
          rateLimitInfo.innerHTML = `Last message was sent too recently. Please wait <span class="countdown">${newRemainingMinutes}:${newRemainingSeconds.toString().padStart(2, '0')}</span>`;
        }
      }, 1000);

      return false;
    }

    submitBtn.disabled = false;
    rateLimitInfo.textContent = `You can send one message every ${RATE_LIMIT_MINUTES} minutes`;
    return true;
  }

  async function initializeForm() {
    const { config, source } = getPluginConfig();

    if (!config) {
      handleInvalidConfig();
      return;
    }

    // Update UI based on configuration
    if (config.authorRequired) {
      document.getElementById('authorOptionalLabel').style.display = 'none';
      document.getElementById('authorRequiredLabel').style.display = 'inline';
      document.getElementById('authorImageOptionalLabel').style.display = 'none';
      document.getElementById('authorImageRequiredLabel').style.display = 'inline';
      document.getElementById('authorDrawOptionalLabel').style.display = 'none';
      document.getElementById('authorDrawRequiredLabel').style.display = 'inline';
      authorInput.required = true;
      authorImageInput.required = true;
      authorDrawInput.required = true;
    }

    if (config.messageRequired) {
      document.getElementById('messageOptionalLabel').style.display = 'none';
      document.getElementById('messageRequiredLabel').style.display = 'inline';
      messageInput.required = true;
      messageInput.placeholder = 'Message is required';
    }

    // Load saved author
    const savedAuthor = localStorage.getItem(AUTHOR_STORAGE_KEY);
    if (savedAuthor) {
      authorInput.value = savedAuthor;
      authorImageInput.value = savedAuthor;
      authorDrawInput.value = savedAuthor;
    }

    // Fetch and display last message
    lastMessageContent.innerHTML = '<div class="last-message-loading">Loading last message...</div>';
    lastMessageCard.style.display = 'block';

    const lastMessage = await fetchLastMessage();
    displayLastMessage(lastMessage);
    checkCanSendBasedOnLastMessage(lastMessage);

    // Show debug info
    let sourceText = source;
    if (source === 'manual_override') sourceText = '‚öôÔ∏è Manual Override';
    else if (source === 'url_encoded') sourceText = 'Encoded URL (saved)';
    else if (source === 'url_legacy') sourceText = 'Legacy URL (saved)';
    else if (source === 'localStorage') sourceText = 'localStorage';

    debugInfo.innerHTML = `
      Plugin ID: ${config.pluginId}<br>
      Source: <span class="plugin-source">${sourceText}</span><br>
      Author Required: ${config.authorRequired ? 'Yes' : 'No'}<br>
      Message Required: ${config.messageRequired ? 'Yes' : 'No'}<br>
      Max Message Length: ${MAX_MESSAGE_LENGTH}<br>
      Stream Limit: ${STREAM_LIMIT} messages<br>
      Max Total Size: ${MAX_TOTAL_SIZE} bytes
    `;
    debugInfo.style.display = 'block';

    if (source === 'localStorage') {
      showMessage('‚úì Using saved configuration from previous session', 'success');
      setTimeout(() => {
        statusMessage.classList.remove('show');
      }, 3000);
    } else if (source === 'manual_override') {
      showMessage('‚úì Using manually provided configuration', 'success');
      setTimeout(() => {
        statusMessage.classList.remove('show');
      }, 3000);
    }
  }

  function handleInvalidConfig() {
    if (encodedParam) {
      showMessage('‚ö† Invalid or corrupted configuration parameter', 'error');
    } else if (legacyWebhookParam) {
      showMessage('‚ö† Invalid plugin ID or webhook URL format', 'error');
    } else {
      showMessage('‚ö† No configuration detected. Please enter a Plugin ID or Webhook URL below, or scan the QR code.', 'warning');
    }
  }

  // Webhook override change handler
  webhookOverride.addEventListener('input', () => {
    initializeForm();
  });

  // Form submission
  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const { config } = getPluginConfig();
    if (!config || !config.pluginId) {
      showMessage('Error: No plugin ID available. Please enter one in the advanced settings or scan the QR code.', 'error');
      return;
    }

    let messageText = '';
    let authorText = '';
    let imageUrl = '';
    let imageData = '';

    if (currentMode === 'message') {
      messageText = messageInput.value.trim();
      authorText = authorInput.value.trim() || 'Anonymous';

      if (config.messageRequired && !messageText) {
        showMessage('Message is required.', 'error');
        messageInput.classList.add('error');
        return;
      }

      if (!messageText) {
        showMessage('Please enter a message.', 'error');
        return;
      }
    } else if (currentMode === 'image') {
      imageUrl = imageUrlInput.value.trim();
      authorText = authorImageInput.value.trim() || 'Anonymous';

      if (!imageUrl) {
        showMessage('Please enter an image URL.', 'error');
        return;
      }

      try {
        new URL(imageUrl);
      } catch (e) {
        showMessage('Please enter a valid image URL.', 'error');
        return;
      }
    } else if (currentMode === 'draw') {
      authorText = authorDrawInput.value.trim() || 'Anonymous';
      imageData = getCanvasDataURL(0.7);

      const sizeKB = Math.round((imageData.length * 3/4) / 1024);
      if (sizeKB > MAX_IMAGE_SIZE_KB) {
        showMessage(`Drawing is too large (${sizeKB} KB). Please simplify your drawing or use fewer colors.`, 'error');
        return;
      }
    }

    if (config.authorRequired && authorText === 'Anonymous') {
      showMessage('Author name is required.', 'error');
      return;
    }

    submitBtn.disabled = true;
    submitBtn.textContent = 'Sending...';

    const webhookUrl = `https://usetrmnl.com/api/custom_plugins/${config.pluginId}`;

    try {
      const newMessage = {
        message: messageText || undefined,
        author: authorText,
        image_url: imageUrl || imageData || undefined,
        timestamp_utc: new Date().toISOString()
      };

      const currentMessages = await fetchAllMessages();
      let updatedMessages = [...currentMessages, newMessage];

      if (updatedMessages.length > STREAM_LIMIT) {
        updatedMessages = updatedMessages.slice(-STREAM_LIMIT);
      }

      const streamingPayload = {
        merge_variables: {
          messages: updatedMessages
        },
        merge_strategy: "stream",
        stream_limit: STREAM_LIMIT
      };

      const streamingSize = getJsonSize(streamingPayload);
      console.log(`Streaming payload size: ${streamingSize} bytes`);

      let finalPayload;
      let useStreaming = true;

      if (streamingSize <= MAX_TOTAL_SIZE) {
        finalPayload = streamingPayload;
        console.log('Using streaming approach with', updatedMessages.length, 'messages');
      } else {
        useStreaming = false;
        finalPayload = {
          merge_variables: {
            messages: [newMessage]
          }
        };

        const singleMessageSize = getJsonSize(finalPayload);
        console.log(`Single message payload size: ${singleMessageSize} bytes`);

        if (singleMessageSize > MAX_TOTAL_SIZE) {
          showMessage('Message too large to send. Please shorten your message or simplify your drawing.', 'error');
          submitBtn.disabled = false;
          submitBtn.textContent = 'Send Message';
          return;
        }

        showMessage('‚ö† Older messages were cleared to make space for this message', 'warning');
        setTimeout(() => {
          statusMessage.classList.remove('show');
        }, 5000);
      }

      console.log('Sending to:', webhookUrl);
      console.log('Final payload size:', getJsonSize(finalPayload), 'bytes');

      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(finalPayload)
      });

      console.log('Response status:', response.status);

      if (response.ok) {
        if (useStreaming) {
          showMessage('‚úì Message sent successfully!', 'success');
        } else {
          showMessage('‚úì Message sent! (Older messages cleared)', 'success');
        }

        const newLastMessage = await fetchLastMessage();
        displayLastMessage(newLastMessage);
        checkCanSendBasedOnLastMessage(newLastMessage);

        // Clear form
        messageInput.value = '';
        imageUrlInput.value = '';
        charCount.textContent = `0/${MAX_MESSAGE_LENGTH}`;
        imageValidation.className = 'validation';
        imagePreview.className = 'image-preview';
        imagePreview.innerHTML = '';

        // Clear canvas
        if (currentMode === 'draw') {
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          drawingHistory = [];
          currentStep = -1;
          saveCanvasState();
        }
      } else {
        const errorText = await response.text();
        console.error('Error response:', errorText);

        if (response.status === 413) {
          showMessage('Message too large. Please shorten your message or simplify your drawing.', 'error');
        } else if (response.status === 429) {
          showMessage('Rate limit exceeded. Please wait before sending another message.', 'error');
        } else {
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
      }
    } catch (error) {
      console.error('Full error:', error);
      showMessage(`Failed to send message: ${error.message}`, 'error');
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Send Message';
    }
  });

  document.addEventListener('DOMContentLoaded', initializeForm);
</script>
</body>
</html>